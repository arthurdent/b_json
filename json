#!/bin/bash

# Shifts json left 1
# Removes whitespace
# Return false when length is zero
pop() {
	
	json="${json:1}" # remaining to be parsed
	
	(( ${#ch} > 0 )) # return
	
}

peek() {

	[[ "$@" ]] && echo "${json:0:$@}" || echo "${json:0:1}"

	(( ${#ch} > 0 )) # return
}

json_init() {

	escape="" is_string=""

	# Remove whitespace from non-strings
	while IFS= read -rn1 char; do
		case "$char" in
			\\) escape="on" ;;&
			\") [[ "$is_string" ]] && [[ ! "$escape" ]] && is_string="" || is_string="on"; escape="" ;;&
			*) [[ "$is_string" || "$char" =~ [^[:space:]] ]] && cleaned+="$char" ; escape="" ;;
		esac
	done <<< "$@"

	json="$cleaned" ch="${json:0:1}"

}

# Debug: create indented blocks
b_start() { 
	b_echo "${@}"  
	(( indent++ )) 
}

b_end() { 
	(( indent-- )) 
	b_echo "$@" 
}

b_echo() {
	pad=""
	for (( i = 0; i < indent; i++ )); do
		pad+="\t"
	done
	echo -e "${pad}$@"
}

# Error: Print to STDERR and exit
error() {
	echo "ERROR: $@" >&2
	exit 1
}

main() {
	json "$@"
}

# Do the thing
json() {

	json_init "$@"

	# indent level
	indent=0

	# Iterate over every character
	# take note if json changes in the meanwhile!
	while [[ "$json" != "" ]] ; do	

		case "$ch" in

			'{')
				parse_object
				;;
			'[')
				parse_array 
				;;
			*)
				b_echo "[other] : $ch"
				;;

		esac

		next

	done


}


# Parse an object - {} - string : value [, string : value]
parse_object() {

	# Make sure it's an object.
	b_start "<object>"
	[[ "$ch" != '{' ]] && error "OBJECT - Expected: '{', found '$ch'"
	#TODO: [[ "$ch" != "{" ]] && error "OBJECT" "{" "$ch" # - Expected: '{', found '$ch'"

	while next ; do

		# string : value [, string: value]
		parse_string
		[[ "$ch" != ':' ]] && error "OBJECT - Expected: ':' - Found: '$ch'"
		next
		parse_value

		# Check for remaining members
		[[ "$ch" == ',' ]] && continue
		[[ "$ch" == '}' ]] && break
		error "OBJECT - Expected: ',' or '}' - Found: '$ch'"

	done

	# Make sure this object ends.
	[[ "$ch" != '}' ]] && error "OBJECT - Expected: '}', found '$ch'"
	b_end "</object>"
	next

}

# Parse an array - [] - value [, value]
parse_array() {
	
	# Make sure this is an array.
	b_start "<array>"
	[[ "$ch" != '[' ]] && error "ARRAY - Expected: '[', found '$ch'"

	while next ; do

		parse_value

		# Check for remaining values
		[[ "$ch" == ',' ]] && continue
		[[ "$ch" == ']' ]] && break
		error "ARRAY - Expected: ',' or ']' - Found: ${json:0:6} ..."

	done
	
	# Make sure this array ends
	[[ "$ch" != ']' ]] && error "ARRAY - Expected: ']', found '$ch'"
	b_end "</array>"
	next
 
}

parse_value() {

	b_start "<value>"

	case "$ch" in
		\")
			parse_string
			;;
	[:digit:])
			parse_number
			;;
		'{')
			parse_object
			;;
		'[')
			parse_array
			;;
		't'|'f')
			parse_boolean || error "VALUE - Expected: string, number, object, array, true, false, or null - Found: '${json:0:6} ...'"
			;;
		'n')
			parse_null || error "VALUE - Expected: string, number, object, array, true, false, or null - Found: '${json:0:6} ...'"
			;;
		*)
			error "VALUE - Expected: string, number, object, array, true, false, or null - Found: '${json:0:6} ...'"
			;;
	esac

	b_end "</value>"

}

parse_string() {

	[[ "$ch" != '"' ]] && error "STRING - Expected: '\"', found '$ch'"
	b_start "<string>"
	next # Remove "

	# TODO: \"
	string=${json%%\"*}
	json=${json#"${string}"}
	ch="${json:0:1}" # TODO: line technically unecessary, for debugging

	b_echo "$string"

	[[ "$ch" != '"' ]] && error "STRING - Expected: '\"', found '$ch'"
	b_end "<string>"
	next # Remove "

	
}

# {int frac, int exp, int frac exp}
parse_number() {
	:
}

parse_boolean() {

	value=${json%%[^[:alpha:]]*}
	json=${json#$value}
	ch=${json:0:1}

	if [[ "$value" == 'true' ]]; then
		b_echo "boolean: true"
	elif [[ "$value" == 'false' ]]; then
		b_echo "boolean: false"
	else
		return 1
	fi

}

parse_null() {

	value=${json%%[^[:alpha:]]*}
	json=${json#$value}
	ch=${json:0:1}

	if [[ "$value" == 'null' ]]; then
		b_echo "<null>"
	else
		return 1
	fi

}

main "$@"
